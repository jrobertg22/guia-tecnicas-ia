<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cuestionario: Tema 07 - Técnicas de IA</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Arvo:wght@700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1e293b; /* Azul pizarra suave */
            --card-bg: #f8fafc;
            --primary: #f7b212;
            --text-main: #1e293b;
            --text-light: #64748b;
            --accent: #3b82f6;
            --success: #15803d;
            --error: #b91c1c;
            --feedback-bg: #f1f5f9;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .quiz-container {
            width: 90%;
            max-width: 700px;
            background: var(--card-bg);
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            padding: 40px;
            position: relative;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            position: absolute;
            top: 0;
            left: 0;
        }

        #progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
        }

        h1 {
            font-family: 'Arvo', serif;
            font-size: 1.6rem;
            margin: 0;
            color: var(--bg-color);
        }

        .question-number {
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 1px;
            margin-bottom: 8px;
            display: block;
        }

        .question-text {
            font-size: 1.2rem;
            line-height: 1.5;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .multi-hint {
            font-size: 0.8rem;
            color: var(--text-light);
            font-style: italic;
            display: block;
            margin-top: -15px;
            margin-bottom: 15px;
        }

        .options-list {
            list-style: none;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-item {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 12px 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            font-size: 0.95rem;
        }

        .option-item:hover:not(.disabled) {
            border-color: var(--accent);
            background-color: #eff6ff;
        }

        .option-item.selected {
            border-color: var(--primary);
            background-color: #fefce8;
        }

        .option-item.correct-ans {
            border-color: var(--success);
            background-color: #f0fdf4;
            color: var(--success);
            font-weight: 600;
        }

        .option-item.wrong-ans {
            border-color: var(--error);
            background-color: #fef2f2;
            color: var(--error);
        }

        .option-item.disabled {
            cursor: default;
            opacity: 0.8;
        }

        input { margin-right: 12px; }

        .feedback-area {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            background: var(--feedback-bg);
            border-left: 4px solid var(--accent);
            display: none;
        }

        .feedback-title {
            font-weight: 700;
            display: block;
            margin-bottom: 5px;
        }

        .justification {
            font-size: 0.9rem;
            line-height: 1.4;
            color: var(--text-light);
        }

        .nav-buttons {
            margin-top: 25px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .btn-validate { background: var(--primary); color: #000; flex-grow: 1; }
        .btn-next { background: var(--bg-color); color: white; }
        .btn-prev { background: #e2e8f0; color: var(--text-light); }
        button:disabled { opacity: 0.3; cursor: not-allowed; }

        #result-screen { text-align: center; display: none; }
        .score-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 6px solid var(--primary);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: 700;
            margin: 20px auto;
        }
    </style>
</head>
<body>

<div class="quiz-container">
    <div class="progress-bar-container"><div id="progress-fill"></div></div>
    
    <div id="quiz-screen">
        <header>
            <span class="question-number" id="q-count"></span>
            <h1>Tema 7: Clustering</h1>
        </header>

        <div id="q-text" class="question-text"></div>
        <span id="q-hint" class="multi-hint"></span>
        <div class="options-list" id="options-container"></div>

        <div class="feedback-area" id="feedback-area">
            <span class="feedback-title" id="feedback-status"></span>
            <p class="justification" id="justification-text"></p>
        </div>

        <div class="nav-buttons">
            <button class="btn-prev" id="btn-prev" onclick="changeQuestion(-1)">Anterior</button>
            <button class="btn-validate" id="btn-validate" onclick="validateCurrent()">Validar Respuesta</button>
            <button class="btn-next" id="btn-next" onclick="changeQuestion(1)" disabled>Siguiente</button>
        </div>
    </div>

    <div id="result-screen">
        <h1>¡Test Completado!</h1>
        <div class="score-circle" id="final-score"></div>
        <p>Has finalizado el repaso sobre Agrupamiento o clasificación no supervisada.</p>
        <div style="text-align: left; background: #f1f5f9; padding: 20px; border-radius: 12px; margin-top: 20px;">
            <h3>Sugerencias de Repaso:</h3>
            <ul id="suggested-topics"></ul>
        </div>
        
        <button class="btn-next" style="margin-top: 20px; width: 100%;" onclick="location.reload()">Reiniciar Test</button>
        <button class="btn-prev" style="margin-top: 10px; width: 100%; border: 2px solid #e2e8f0;" onclick="window.location.href='index.html'">Ir al Menú Principal</button>
    </div>
</div>

<script>
    const quizData = [
        {
            question: "1. Indica cuáles de las siguientes afirmaciones son correctas:",
            options: [
                "A. El clústering permite agrupar objetos similares entre sí.",
                "B. El clústering es un método de aprendizaje supervisado.",
                "C. El clústering puede resultar útil como etapa previa a la aplicación de un método de aprendizaje supervisado.",
                "D. El clústering da lugar a árboles de decisión."
            ],
            correct: [0, 2],
            type: "multiple",
            topic: "7.2. Conceptos de Clustering",
            justification: "El clustering es un método de aprendizaje NO supervisado que agrupa objetos por similitud. Se usa a menudo para descubrir clases desconocidas y etiquetarlas antes de aplicar técnicas de clasificación supervisada."
        },
        {
            question: "2. Indica cuál de las siguientes afirmaciones es correcta:",
            options: [
                "A. Diferentes algoritmos de clústering dan lugar a los mismos agrupamientos finales.",
                "B. Los algoritmos jerárquicos aglomerativos generan clústeres pequeños que iterativamente van agrupando entre sí.",
                "C. Los agrupamientos solapados se obtienen aplicando algoritmos de clústering jerárquicos.",
                "D. Los algoritmos de clústering no permiten detectar datos anómalos."
            ],
            correct: [1],
            type: "single",
            topic: "7.2 y 7.4. Tipos de Algoritmos",
            justification: "Los algoritmos aglomerativos funcionan de abajo hacia arriba (bottom-up), comenzando con un clúster por cada objeto y agrupándolos sucesivamente. El clustering sí permite detectar anomalías (outliers)."
        },
        {
            question: "3. Si se pretende generar agrupamientos exclusivos se ha de aplicar:",
            options: ["A. Algoritmo Fuzzy C-means.", "B. Algoritmo k-means.", "C. Algoritmo EM.", "D. Ninguno de los anteriores."],
            correct: [1],
            type: "single",
            topic: "7.3. Agrupamiento exclusivo",
            justification: "K-means es el ejemplo clásico de agrupamiento exclusivo, donde cada objeto puede pertenecer únicamente a un clúster. EM es probabilista y Fuzzy C-means es solapado."
        },
        {
            question: "4. Si se pretende crear agrupamientos con formas irregulares se ha de aplicar:",
            options: ["A. Algoritmo k-means.", "B. Algoritmos basados en densidad.", "C. Algoritmo Fuzzy C-means.", "D. Ninguno de los anteriores."],
            correct: [1],
            type: "single",
            topic: "7.2. Algoritmos basados en densidad",
            justification: "Mientras que k-means tiende a crear formas circulares/esféricas, los algoritmos basados en densidad (como DBSCAN) son ideales para identificar clústeres con formas irregulares basándose en umbrales de densidad local."
        },
        {
            question: "5. Si se pretende modelar los clústeres mediante una función probabilista se ha de aplicar:",
            options: ["A. Algoritmo Fuzzy C-means.", "B. Algoritmo k-means.", "C. Algoritmo EM.", "D. Ninguno de los anteriores."],
            correct: [2],
            type: "single",
            topic: "7.5. Agrupamiento probabilista",
            justification: "El algoritmo EM (Expectation-Maximization) es el método representativo para generar agrupamientos probabilistas basándose en modelos estadísticos de mezclas finitas."
        },
        {
            question: "6. Si se mide la similitud entre dos clústeres mediante la medida de enlace completo:",
            options: [
                "A. Se tiene en cuenta la similitud entre los dos puntos más cercanos de ambos clústeres.",
                "B. Se tiene en cuenta la similitud entre los dos puntos más lejanos de ambos clústeres.",
                "C. Se tiene en cuenta la distancia promedio que existe entre todos los puntos de ambos clústeres.",
                "D. Se tiene en cuenta la distancia entre los centroides de ambos clústeres."
            ],
            correct: [1],
            type: "single",
            topic: "7.2. Medida de distancia (linkage)",
            justification: "El enlace completo (complete-linkage) es el caso opuesto al enlace sencillo; considera la distancia mayor existente entre cualquier par de puntos de los dos clústeres comparados."
        },
        {
            question: "7. Indica cuáles de las siguientes afirmaciones, respecto del algoritmo k-means, son correctas:",
            options: [
                "A. El algoritmo k-means asigna los objetos a los clústeres en función de su cercanía al centroide de cada clúster.",
                "B. En cada iteración el algoritmo k-means mantiene fijos los centroides.",
                "C. Es un algoritmo basado en densidad.",
                "D. En cada iteración el algoritmo recalcula los centroides."
            ],
            correct: [0, 3],
            type: "multiple",
            topic: "7.3. Algoritmo k-means",
            justification: "K-means es un algoritmo iterativo basado en distancia. En cada ciclo asigna objetos al centro más cercano y luego recalcula la posición de dicho centroide promediando los puntos asignados."
        },
        {
            question: "8. Indica cuáles de las siguientes afirmaciones, respecto a los algoritmos de clústering jerárquicos, son correctas:",
            options: [
                "A. Se utiliza la medida de utilidad de la categoría para realizar particiones.",
                "B. En un algoritmo divisorio inicialmente a cada clúster se le asigna un objeto.",
                "C. Utilizan una matriz de similitud para llevar a cabo la decisión de agrupar clústeres.",
                "D. Se puede utilizar la medida de enlace promedio para calcular las distancias entre clústeres."
            ],
            correct: [0, 2, 3],
            type: "multiple",
            topic: "7.4. Agrupamiento jerárquico",
            justification: "Los jerárquicos usan matrices de similitud/distancia y medidas de enlace (como el promedio). La 'utilidad de la categoría' mide la calidad de las particiones. En los divisorios, se empieza con un clúster único para todos los datos."
        },
        {
            question: "9. Indica cuáles de las siguientes afirmaciones son correctas respecto al algoritmo EM:",
            options: [
                "A. Es un algoritmo basado en densidades.",
                "B. Tiene como base el modelo estadístico denominado mezclas finitas.",
                "C. El objetivo es conocer los parámetros de una función probabilista general que modela los clústeres.",
                "D. En la fase de esperanza se calculan las probabilidades de pertenencia de las instancias a los clústeres."
            ],
            correct: [1, 2, 3],
            type: "multiple",
            topic: "7.5. Agrupamiento probabilista (EM)",
            justification: "EM se basa en mezclas finitas (distribuciones de probabilidad). Su objetivo es estimar los parámetros (media, varianza) que definen esas funciones. La fase E (Esperanza) calcula las probabilidades de pertenencia."
        },
        {
            question: "10. Indica cuáles de las siguientes afirmaciones son correctas respecto al algoritmo Fuzzy C-means:",
            options: [
                "A. Una instancia puede pertenecer a más de un clúster si se aplica el algoritmo Fuzzy C-means.",
                "B. Las variables de entrada son conjuntos difusos.",
                "C. Los clústeres se modelan como conjuntos difusos.",
                "D. Permite obtener clústeres jerárquicos."
            ],
            correct: [0, 2],
            type: "multiple",
            topic: "7.6. Agrupamiento solapado (Fuzzy)",
            justification: "Fuzzy C-means permite el solapamiento: un objeto tiene un grado de pertenencia a varios grupos. Para ello, los clústeres se modelan matemáticamente como conjuntos difusos."
        }
    ];

    let currentIdx = 0;
    const userAnswers = new Array(quizData.length).fill(null).map(() => []);
    const validatedArr = new Array(quizData.length).fill(false);

    function render() {
        const q = quizData[currentIdx];
        const isValidated = validatedArr[currentIdx];
        document.getElementById('q-count').innerText = `Pregunta ${currentIdx + 1} de ${quizData.length}`;
        document.getElementById('q-text').innerText = q.question;
        document.getElementById('q-hint').innerText = q.type === "multiple" ? "(Selecciona todas las opciones que correspondan)" : "";
        document.getElementById('progress-fill').style.width = `${((currentIdx + 1) / quizData.length) * 100}%`;
        const container = document.getElementById('options-container');
        container.innerHTML = "";
        q.options.forEach((opt, i) => {
            const div = document.createElement('div');
            const isSelected = userAnswers[currentIdx].includes(i);
            let statusClass = "";
            if (isValidated) {
                if (q.correct.includes(i)) statusClass = "correct-ans";
                else if (isSelected) statusClass = "wrong-ans";
                div.classList.add("disabled");
            } else if (isSelected) {
                statusClass = "selected";
            }
            div.className = `option-item ${statusClass}`;
            div.innerHTML = `<input type="${q.type === 'multiple' ? 'checkbox' : 'radio'}" ${isSelected ? 'checked' : ''} ${isValidated ? 'disabled' : ''}> <span>${opt}</span>`;
            if (!isValidated) div.onclick = () => selectOption(i);
            container.appendChild(div);
        });
        document.getElementById('feedback-area').style.display = isValidated ? "block" : "none";
        if (isValidated) {
            const isCorrect = checkCorrectness(currentIdx);
            document.getElementById('feedback-status').innerText = isCorrect ? "✓ ¡Correcto!" : "✗ Revisión Necesaria";
            document.getElementById('feedback-status').style.color = isCorrect ? "var(--success)" : "var(--error)";
            document.getElementById('justification-text').innerText = q.justification;
        }
        document.getElementById('btn-prev').disabled = currentIdx === 0;
        document.getElementById('btn-validate').style.display = isValidated ? "none" : "block";
        document.getElementById('btn-next').disabled = !isValidated;
        document.getElementById('btn-next').innerText = currentIdx === quizData.length - 1 ? "Finalizar" : "Siguiente";
    }

    function selectOption(idx) {
        if (quizData[currentIdx].type === "single") userAnswers[currentIdx] = [idx];
        else {
            const pos = userAnswers[currentIdx].indexOf(idx);
            if (pos > -1) userAnswers[currentIdx].splice(pos, 1);
            else userAnswers[currentIdx].push(idx);
        }
        render();
    }

    function validateCurrent() {
        if (userAnswers[currentIdx].length === 0) return alert("Selecciona al menos una respuesta.");
        validatedArr[currentIdx] = true;
        render();
    }

    function checkCorrectness(idx) {
        const user = userAnswers[idx].sort().join(',');
        const correct = quizData[idx].correct.sort().join(',');
        return user === correct;
    }

    function changeQuestion(step) {
        if (step === 1 && currentIdx === quizData.length - 1) return showResults();
        currentIdx += step;
        render();
    }

    function showResults() {
        document.getElementById('quiz-screen').style.display = 'none';
        document.getElementById('result-screen').style.display = 'block';
        let score = 0;
        const failedTopics = new Set();
        quizData.forEach((q, i) => { if (checkCorrectness(i)) score++; else failedTopics.add(q.topic); });
        document.getElementById('final-score').innerText = `${score}/10`;
        const list = document.getElementById('suggested-topics');
        list.innerHTML = "";
        failedTopics.forEach(t => { const li = document.createElement('li'); li.innerText = t; list.appendChild(li); });
        if (failedTopics.size === 0) list.innerHTML = "<li>¡Excelente trabajo! Dominas los conceptos de Clustering.</li>";
    }
    render();
</script>
</body>
</html>